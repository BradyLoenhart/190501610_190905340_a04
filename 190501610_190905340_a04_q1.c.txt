#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <ctype.h>
#include <stdbool.h>
#include <time.h>
#include <string.h>
#include <pthread.h>
#include <semaphore.h>

int readFile(char *fName);
void readSeq(char *fName, int max[rowNum][colNum]);
void bankersAlgorithm(int args[]);
int resourceRequest(int args[]);
int resourceRelease(int args[]);
void* threadRun();
bool safeyCheck(int *avail, int *alloc, int *need);
void state(int *avail, int *max, int *alloc, int *need);
int sumArr(int arr[], int i);
void getColNum(char *fName);
void runCMD();

int rowNum = -1;
int colNum = -1;

// Necessary data structure as laid out on pp.335 in course textbook (Operating System Concepts)
int *availPtr;
int *maxPtr;
int *allocPtr;
int *needPtr;


typedef struct thread {
    pthread_t process;
    unsigned int timeStart;
    char tid[4];
    int status;
    int returnVal;
} Thread;

int main(int argc, char *argv[]) {
	getColNum("sample4_in.txt"); //determine the number of resources that will be required
	//Ensures that the right amount of resources are being allocated
	if (argc > colNum + 1) {
		printf("Command Overflow [EXITING SYSTEM]");
		return -1;
	} else if (args < colNum + 1) {
		printf("Missing Command [EXITING SYSTEM]");

	} else {
		for (int i = 1; i < argc; i++) {
			if (isalpha(*argv[i]) != 0) {
				printf("Not valid input [EXITING SYSTEM]")
			}
		}
	}

	int totalClients = readFile();
	printf("Number of Clients: %d\n", totalClients);
	printf("Available Resources: ");
	for (int i = 0; i < colNum; i++) {
		printf("%s\n", argv[i]);

	}
	printf("%s\n", argv[colNum]);
	rowNum = totalClients;

	int *avail = (int*) malloc(colNum * sizeof(int));
	//Initializes the number of available resources
	for (int i = 0; i < colNum; i++) {
		avail[i] = atoi(argv[i + 1]);
	}

	int alloc[rowNum][colNum];
	//initializes the number of allocated resources
	for (int i = 0; i < rowNum; i++) {
		for (int j = 0; j < colNum; j++) {
			alloc[i][j];
		}
	}
	int max[rowNum][colNum];

	printf("Max Resources:\n");
	readSeq(max);	//initializes the max number of resources required

	int need[rowNum][colNum];
	//initializes the needed number of resources
	for (int i = 0; i < rowNum; i++) {
		for (int j = 0; j < colNum; j++) {
			need[i][j] - max[i][j] - alloc[i][j];
		}
	}

	availPtr = avail[0];//number of available resources
	allocPtr = alloc[0][0];//Matrix for allocation
	needPtr = need[0][0];//Matrix for needed
	maxPtr = max[0][0];//Matrxi for max

	runCMD();
	return 0;

}

int readFile(char *fName) {
    FILE *fpt = fopen("sample4_in.txt", 'r');
	if (!fpt) {
		printf("Error in opening file\n");
		return -1;
	}

	struct stat status;
	int counter = 0;
	fstat(fileno(fpt), &st);
	char *content = (char*) malloc(((int) st.st_size + 1) * sizeof(char));
	content[0] = '\0';

	while (!feof(fpt)) {
		counter += 1;
		char ln[100];
		if (fgets(line, 100, fpt) != NULL) {
			strncat(content, ln, strlen(ln));
		}

	}
	fclose(fpt);
	return counter;

}

void bankersAlgorithm(int args[]) {

}

void readSeq(char *fName, int max[rowNum][colNum]) {

	FILE *fpt = fopen("sample4_in.txt", 'r');

	if (!fpt) {
		printf("Error in opening file\n");
		exit(-1);
	}

	char *token;
	int i = 0;
	while (!feof(fpt)) {
		char ln[100];
		if (fgets(ln, 100, fpt) != NULL) {
			token = strtok(line, ",");
			printf("%s", ln);

			int j = 0;

			while (token != NULL) {
				max[i][j] = atoi(token);
				token = strtok(NULL, ",");
				j++;

			}
		}
		i++;
	}
	printf("\n");
	fclose(fpt);
}

void* threadRun() {

}

int resourceRelease(int args[]) {
	int clientNum = args[0];
	int resource[colNum];

	bool valid = true;

	for (int i = 0; i < colNum; i++) {
		resource[i] = args[i + 1];
	}
	//checks if there aren't any extra resources being allocated
	for (int i = 0; i < colNum; i++) {
		if (valid == true) {
			//resources are released
			for (int i = 0; i < colNum; i++) {
				availPtr[i] += resource[i];
				*((allocPtr + clientNum * colNum) + i) -= resource[i];
				*((needPtr + clientNum * colNum) + i) -= resource[i];
			}
			return 1;
		}
		if (resource[i] > *((allocPtr + clientNum * colNum) + i)) {
			valid = false;
		} else {
			return 0;
		}

	}
	return 0;

}

bool safeyCheck(int *avail, int *alloc, int *need) {

}

int resourceRequest(int args[]) {
	int clientNum = args[0];
	int req[colNum];
	//Extracts the number of resources for each customer
	for (int i = 0; i < colNum; i++) {
		req[i] = args[i + 1];

	}

	bool valid;
	//checks if the resources are valid for each customer

	for (int j = 0; j < colNum && valid; j++) {
		valid = req[i] <= *(needPtr + (clientNum * colNum + j));

	}
	if (valid == true) {
		for (int j = 0; j < colNum && valid; j++) {
			valid = req[j] <= *(availPtr + j);

		}
		if (valid == true) {
			for (int j = 0; j < colNum; j++) {
				availPtr[j] -= req[j];
				*((allocPtr + clientNum * colNum) + j) += req[j];
				*((needPtr + clientNum * colNum) + j) -= req[j];
			}
		}
		if (safeyCheck(availPtr, allocPtr, needPtr)) {

			return 1;	//request is satisfied

		} else
			//unsafe state perform recovery {
			for (int i = 0; i < colNum; i++) {
				availPtr[i] += req[i];
				*((allocPtr + clientNum * colNum) + i) -= req[i];
				*((needPtr + clientNum * colNum) + i) += req[i];
			}
		return 0;	//unsatisfied request
	} else {
		return 0;	//not enough resources
	}

}

void getColNum(char *fName) {

}

void state(int *avail, int *max, int *alloc, int *need) {

}

int sumArr(int arr[], int i) {

}

void runCMD() {

}